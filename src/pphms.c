#include <stdio.h>
#include "miracl.h"
#include <time.h>
#include <string.h>
#include <stdlib.h>

struct data{
    unsigned int len;
    int ik;
    char ciphertext[200];
};

struct key{
    big encryptionKey;
    big decryptionKey;
};

struct patient{
    unsigned long personalNumber;
    struct data name;
    struct data age;
    struct data phoneNumber;
    struct data address;
    struct data disease;
    struct data comment;
}pat;

unsigned int recsize_pat = sizeof(struct patient);

void option();
void modify_option();
void keygen(miracl *mip);
void update(miracl *mip);
struct data updateCipher(struct data d, big t, miracl *mip);
void modify(miracl *mip);
void del();
void addRecord(miracl *mip);
struct data enc(char *msg, big encryptionKey, miracl *mip);
void readRecord(miracl *mip);
void dec(struct data d, big decryptionKey, miracl *mip);
void read();
static char *rand_string(char *str, size_t size);

/* Use secp256k1 elliptic curve: y^2=x^3 + 7 */

/* Prime of the finite field */

char *ecp="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F";

/* elliptic curve parameter B */

char *ecb="7";

/* Generator point of secp256k1 */

char *ecx="79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798";
char *ecy="483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8";

/* Order of the group generated by G, such that nG = Infinity */

char *ecn="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141";

int rand_len = 16;
int ptx_len = 32;

int main()
{
    unsigned int choice;
    epoint *g,*ea,*eb;
    big a,b,p,q,x,y;
    time_t seed;
    miracl *mip;

    #ifndef MR_NOFULLWIDTH   
        mip=mirsys(36,0);
    #else
        mip=mirsys(36,MAXBASE);
    #endif
    
    printf("\n********** Privacy Preserving Hospital Management System: **********\n");

    while(1)
    {
        a=mirvar(0);
        b=mirvar(0);
        p=mirvar(0);
        q=mirvar(0);
        x=mirvar(0);
        y=mirvar(0);
        
        convert(0,a);
        mip->IOBASE=16;
        cinstr(b,ecb);
        cinstr(p,ecp);      
        ecurve_init(a,b,p,MR_BEST);  /* Use PROJECTIVE if possible, else AFFINE coordinates */
    
        g=epoint_init();
        cinstr(x,ecx);
        cinstr(y,ecy);
        mip->IOBASE=10;
        epoint_set(x,y,0,g);
        ea=epoint_init();
        eb=epoint_init();
        epoint_copy(g,ea);
        epoint_copy(g,eb);

        time(&seed);
        irand((unsigned long)seed); 

        option();
        printf("ENTER  YOUR CHOICE\n");
        scanf("%u",&choice);
        switch(choice)
        {
            case 1:
                    keygen(mip);  //  Key generation algorithm. Generate an initial epoch key.
                    break;
            case 2:
                    system("clear");
                    addRecord(mip);  //  Add a new encrypted record.                   
                    break;
            case 3:
                    system("clear");
                    modify(mip);   // Modify an encrypted record.
                    break;  
            case 4:
                    del();  // Delete a record.
                    break;  
            case 5:
                    system("clear");
                    readRecord(mip);  //  Read a record, output the decrypted values.                 
                    break;
            case 6:
                    update(mip);  //  Token generation and update algorithm. Generate a new epoch key and update all ciphertexts from the old key to the new key.                   
                    break;                  
            case 7:
                    read();  // Read all encrypted records.
                    break;
            case 8:
                    remove("HealthData");  // Delete the whole documents.
                    remove("KeyMaterial");    
                    break;             
            case 0:  
                    exit(0);
            }
    }
    return 0;
}

void option()
{
        printf("\nENTER YOUR FOLLOWING CHOICE\n");
        printf("1 ==> KEY GENERATION\n");
        printf("2 ==> ADD RECORD (ENCRYPTION)\n");
        printf("3 ==> MODIFY RECORD\n"); 
        printf("4 ==> DELETE RECORD\n"); 
        printf("5 ==> READ RECORD (DECRYPTION)\n");
        printf("6 ==> UPDATE KEY AND CIPHERTEXTS\n");
        printf("7 ==> READ ALL RECORD\n");
        printf("8 ==> DELETE FILES\n");
        printf("0 ==> EXIT\n");
}

void modify_option()
{
    printf("\nENTER YOUR FOLLOWING MODIFICATION CHOICE\n");
    printf("1 ==> NEW NAME\n");
    printf("2 ==> NEW AGE\n");
    printf("3 ==> NEW PHONE NUMBER\n");
    printf("4 ==> NEW ADDRESS\n");
    printf("5 ==> NEW DISEASE\n");
    printf("6 ==> NEW COMMENT\n");
    printf("0 ==> EXIT\n");
}

/*  Key generation algorithm. Generate an initial epoch key.  */
/*  Store the key k in the file "KeyMaterial".  */
void keygen(miracl *mip)
{
    FILE *fk; 
    struct key k;
    k.encryptionKey=mirvar(0);
    k.decryptionKey=mirvar(0);
    big yd,z,nn;

    yd=mirvar(0);
    z=mirvar(0);
    nn=mirvar(0);
    mip->IOBASE=16;
    cinstr(nn,ecn);
    mip->IOBASE=10;
    
    fk = fopen("KeyMaterial","a+");

    /*  Generate a valid key pair for encryption and decryption.  */
    do 
    {
    bigbits(160,k.encryptionKey);
    } while(egcd(k.encryptionKey,nn,z)!=1); 
    xgcd(k.encryptionKey,nn,k.decryptionKey,yd,z);
   
    cotnum(k.encryptionKey,fk);  // write the initial keys into fk
    cotnum(k.decryptionKey,fk);
    fclose(fk);
}

/*  Token generation and update algorithm.   */
/*  Generate a new epoch key and an update token.   */
/*  Update all ciphertexts from the old key to the new key.  */
void update(miracl *mip)
{
    
    FILE *fk,*fp;
    struct key k0,k1;
    k0.encryptionKey=mirvar(0);
    k0.decryptionKey=mirvar(0);
    k1.encryptionKey=mirvar(0);
    k1.decryptionKey=mirvar(0);
    char buff_encryptionKey[255], buff_decryptionKey[255];

    big t,nn;
   
    t=mirvar(0);
    mip->IOBASE=16;
    nn=mirvar(0);
    cinstr(nn,ecn);

    keygen(mip); // Generate and write the new key into file fk
    
    /* put the new key k1 into the file "KeyMaterial", delete the old key k0 */
    fk = fopen("KeyMaterial","a+");
    FILE *fk_temp = fopen("KeyMaterial_temp","w");
    int count = 0;
    
    rewind(fk);
    for(count=0;count<=1;count++)
    {
        fgets(buff_encryptionKey, 255, (FILE*)fk); // read fk and store a line into buff_encryptionKey    
        fgets(buff_decryptionKey, 255, (FILE*)fk); 
        if(count)
        {
            cinstr(k1.encryptionKey,buff_encryptionKey); 
            cinstr(k1.decryptionKey,buff_decryptionKey); 
            cotnum(k1.encryptionKey,fk_temp);  // write the new key into fk_temp, fk_temp only has the new key
            cotnum(k1.decryptionKey,fk_temp);  
        }
        else
        {
            cinstr(k0.encryptionKey,buff_encryptionKey); 
            cinstr(k0.decryptionKey,buff_decryptionKey); 
        }      
    }

    /* Close all open files */
    fclose(fk);
    fclose(fk_temp);
    
    /* Delete the original file and rename the temperary file as the original file */
    remove("KeyMaterial");
    rename("KeyMaterial_temp","KeyMaterial");


    /*  Compute the update token t */
    multiply(k1.encryptionKey,k0.decryptionKey,t);
    fmodulo(t,nn,t);

    /*  Compute the updated ciphertext, delete old ciphertexts and store updated ciphertexts */
    fp = fopen("HealthData","r+");
    FILE *fp_temp = fopen("HealthData_temp","w");
    rewind(fp); 
    mip->IOBASE=10; 
    while(fread(&pat,recsize_pat,1,fp))
    {   
        pat.name=updateCipher(pat.name,t,mip);
        pat.age=updateCipher(pat.age,t,mip);
        pat.phoneNumber=updateCipher(pat.phoneNumber,t,mip);
        pat.address=updateCipher(pat.address,t,mip);
        pat.disease=updateCipher(pat.disease,t,mip);
        pat.comment=updateCipher(pat.comment,t,mip);

        fwrite(&pat,recsize_pat,1,fp_temp);
    }

    /* Close all open files */
    fclose(fp);
    fclose(fp_temp);
    
    /* Delete the original file and rename the temperary file as the original file */
    remove("HealthData");
    rename("HealthData_temp","HealthData");
}

/* Update data d by token t */
struct data updateCipher(struct data d, big t, miracl *mip)
{
    epoint *ep = epoint_init();
    big r,ct;
    r=mirvar(0);
    ct=mirvar(0);
    bytes_to_big(32,d.ciphertext,ct);
    do
    {
        epoint_set(ct,ct,d.ik,ep); 
        ecurve_mult(t,ep,ep);
        d.ik=epoint_get(ep,ct,ct);
        
    }while (fcomp(r,ct)==0||big_to_bytes(32,ct,d.ciphertext,FALSE)!=32);
    return d;
}

/*  Edit some types of data, replace the old ciphertext to the new ciphertext  */
void modify(miracl *mip)
{
    FILE *fp = fopen("HealthData","r+"); 
    struct patient temp;
    FILE *fp_temp = fopen("HealthData_temp","w");
    unsigned int choice = 1000, searchFlag = 0;
    char msg[20]; 
    FILE *fk = fopen("KeyMaterial","r+");
    struct key k;
    k.encryptionKey=mirvar(0);
    k.decryptionKey=mirvar(0);
    char buff_encryptionKey[255], buff_decryptionKey[255];
    
    rewind(fk);
    fgets(buff_encryptionKey, 255, (FILE*)fk); // read encryptionKey from fk      
    fgets(buff_decryptionKey, 255, (FILE*)fk); // read decryptionKey from fk  
    
    mip->IOBASE=10;  
    cinstr(k.encryptionKey,buff_encryptionKey); 
    cinstr(k.decryptionKey,buff_decryptionKey); 

          
    printf("ENTER PERSONAL NUMBER\n");
    scanf("%lu", &temp.personalNumber); 
    // Move fp file pointer to beginning
    rewind(fp);
    while(fread(&pat,recsize_pat,1,fp))
    {
        if(pat.personalNumber == temp.personalNumber)
        {
            searchFlag = 1;
            while(choice != 0)
            {
                modify_option();
                printf("ENTER  YOUR CHOICE\n");
                scanf("%u",&choice);
                switch(choice)
                {
                    case 1:
                            printf("\nENTER NEW NAME\n");
                            scanf("%s", msg);
                            pat.name=enc(msg,k.encryptionKey,mip);
                            break;
                    case 2: 
                            printf("\nENTER NEW AGE\n");
                            scanf("%s", msg);
                            pat.age=enc(msg,k.encryptionKey,mip);    
                            break;
                    case 3: 
                            printf("\nENTER NEW PHONE NUMBER\n");
                            scanf("%s", msg);
                            pat.phoneNumber=enc(msg,k.encryptionKey,mip);           
                            break;
                    case 4: 
                            printf("\nENTER NEW ADDRESS\n");
                            scanf("%s", msg);     
                            pat.address=enc(msg,k.encryptionKey,mip);  
                            break;

                    case 5: 
                            printf("\nENTER NEW DISEASE\n");
                            scanf("%s",msg);      
                            pat.disease=enc(msg,k.encryptionKey,mip);       
                            break;
                    case 6: 
                            printf("\nENTER NEW COMMENT\n");
                            scanf("%s",msg); 
                            pat.comment=enc(msg,k.encryptionKey,mip);            
                            break;
                    case 0:             
                            break;
                    }
            }
        
        }
        fwrite(&pat,recsize_pat,1,fp_temp);
    }
        if(!searchFlag) 
        printf("\nCANNOT FIND THE RECORD");
        /* Close all open files */
        fclose(fp);
        fclose(fp_temp);
        fclose(fk);
        /* Delete HealthData file and rename HealthData1 file as HealthData */

        remove("HealthData");
        rename("HealthData_temp","HealthData");
}

/*  Delete a record basing on the input personal number  */
void del()
{
    FILE *fp = fopen("HealthData","r+"); 
    struct patient temp;
    FILE *fp_temp = fopen("HealthData_temp","w");
           
    printf("ENTER PERSONAL NUMBER\n");
    scanf("%lu", &temp.personalNumber); 
    // Move fp file pointer to beginning
    rewind(fp);
    while(fread(&pat,recsize_pat,1,fp) == 1)
    {
        if(pat.personalNumber != temp.personalNumber)
        {
            fwrite(&pat,recsize_pat,1,fp_temp);
        }            
    }
        /* Close all open files */
        fclose(fp);
        fclose(fp_temp);
        /* Delete HealthData file and rename HealthData1 file as HealthData */

        remove("HealthData");
        rename("HealthData_temp","HealthData");   
}

/*  ADD a new encrypted record.  */  
void addRecord(miracl *mip)
{   
    epoint *ep = epoint_init();
    FILE *fk = fopen("KeyMaterial","r+");
    FILE *fp = fopen("HealthData","a+");
    struct key k;
    k.encryptionKey=mirvar(0);
    k.decryptionKey=mirvar(0);
    char buff_encryptionKey[255], buff_decryptionKey[255];
    char msg[20]; 
    
    rewind(fk);
    fgets(buff_encryptionKey, 255, (FILE*)fk); // read encryptionKey from fk      
    fgets(buff_decryptionKey, 255, (FILE*)fk); // read decryptionKey from fk  
    
    mip->IOBASE=10;  
    cinstr(k.encryptionKey,buff_encryptionKey); 
    cinstr(k.decryptionKey,buff_decryptionKey); 

    fseek(fp,0,SEEK_END);   
    printf("\nENTER PERSONAL NUMBER\n");
    scanf("%lu", &pat.personalNumber);

    printf("\nENTER NAME\n");
    scanf("%s", msg);
    pat.name=enc(msg,k.encryptionKey,mip);

    printf("\nENTER AGE\n");
    scanf("%s", msg);
    pat.age=enc(msg,k.encryptionKey,mip);

    printf("\nENTER PHONE NUMBER\n");
    scanf("%s", msg);
    pat.phoneNumber=enc(msg,k.encryptionKey,mip);

    printf("\nENTER ADDRESS\n");
    scanf("%s", msg);
    pat.address=enc(msg,k.encryptionKey,mip);

    printf("\nENTER DISEASE\n");
    scanf("%s", msg);
    pat.disease=enc(msg,k.encryptionKey,mip);

    printf("\nENTER COMMENT\n");
    scanf("%s", msg);
    pat.comment=enc(msg,k.encryptionKey,mip);

    fwrite(&pat,recsize_pat,1,fp); // write data pat into file fp
    
    fclose(fk);
    fclose(fp);
}

/*  encrypt msg by the encryption key encryptionKey  */
struct data enc(char *msg, big encryptionKey, miracl *mip)
{
    struct data d;
    epoint *ep = epoint_init();
    char s[20];
    char *ptr;
    big m,r,ct;
    m=mirvar(0); 
    r=mirvar(0);  
    ct=mirvar(0);

    do
    {
    /* Padding random bytes to data, get ptr */
        ptr = (char*)malloc(ptx_len);
        strcpy(ptr, msg);
        strcat(ptr, rand_string(s,rand_len));
        d.len = strlen(ptr)+1-rand_len;

    /*  Encode ptr to m */
        mip->IOBASE=128;
        cinstr(m,ptr); 
        free(ptr);       

    /*  Encryption algorithm. Compute a ciphertext */                 
        epoint_set(m,m,0,ep);     /*  Map m to an elliptic curve point ep */          
        ecurve_mult(encryptionKey,ep,ep);
        d.ik=epoint_get(ep,ct,ct);
    } while (fcomp(r,ct)==0||big_to_bytes(32,ct,d.ciphertext,FALSE)!=32);

    return d;

}

/* Read a record w.r.t. a personal number  */
void readRecord(miracl *mip)
{
    epoint *ep = epoint_init();
    FILE *fk = fopen("KeyMaterial","r+");
    FILE *fp = fopen("HealthData","r+");
    struct key k;
    k.encryptionKey=mirvar(0);
    k.decryptionKey=mirvar(0);
    char buff_encryptionKey[255], buff_decryptionKey[255];

    big m,r,ct;
    char c[100];
    m=mirvar(0); 
    r=mirvar(0);  
    ct=mirvar(0); 
    unsigned long temp;
    int check = 0;

    rewind(fk);
    fgets(buff_encryptionKey, 255, (FILE*)fk); // read encryptionKey from fk      
    fgets(buff_decryptionKey, 255, (FILE*)fk); // read decryptionKey from fk  
    cinstr(k.encryptionKey,buff_encryptionKey); 
    cinstr(k.decryptionKey,buff_decryptionKey); 

    rewind(fp);  
    
    printf("ENTER PERSONAL NUMBER\n");
    scanf("%lu", &temp); 
    
    mip->IOBASE=10; 
    while(fread(&pat,recsize_pat,1,fp)==1)
    {
        if(pat.personalNumber==temp)
        {
            check = 1;

            printf("\nNAME=\n");
            dec(pat.name, k.decryptionKey, mip);

            printf("\nAGE\n");
            dec(pat.age, k.decryptionKey, mip);

            printf("\nPHONE NUMBER\n");
            dec(pat.phoneNumber, k.decryptionKey, mip);

            printf("\nENTER ADDRESS\n");
            dec(pat.address, k.decryptionKey, mip);

            printf("\nENTER DISEASE\n");
            dec(pat.disease, k.decryptionKey, mip);

            printf("\nENTER COMMENT\n");
            dec(pat.comment, k.decryptionKey, mip);
        }
    }

    if(check !=1) 
    printf("CANNOT FIND THE RECORD\n");
    fclose(fk);
    fclose(fp);
}

/* Decrypt data d by the decryption key decryptionKey */
void dec(struct data d, big decryptionKey, miracl *mip)
{
    epoint *ep = epoint_init();
    
   
    big m,r,ct;
    char c[100];
    m=mirvar(0); 
    r=mirvar(0);  
    ct=mirvar(0); 

    bytes_to_big(32,d.ciphertext,ct);
    do
    {
        epoint_set(ct,ct,d.ik,ep); 
        ecurve_mult(decryptionKey,ep,ep);
        epoint_get(ep,m,m);
    }while (fcomp(r,ct)==0);
    
    mip->IOBASE=128; 
    cotstr(m,c);            
    printf("%.*s\n",d.len,c);            
}

/*  Read all encrpyted data  */
void read()
{
    FILE *fp = fopen("HealthData","r");
    
    rewind(fp);                        
    while(fread(&pat,recsize_pat,1,fp)==1)
    {
        printf("\n\n********** %s: %lu **********\n", "Personal number",pat.personalNumber);  
        printf("\n%s %s %s %s %s %s", pat.name.ciphertext, pat.age.ciphertext, pat.phoneNumber.ciphertext, pat.address.ciphertext, pat.disease.ciphertext, pat.comment.ciphertext);  
    }
    fclose(fp);       
}

/* Output a random string  */    
static char *rand_string(char *str, size_t size)
{
    const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,.-#'?!";
    //srand(time(0)); 
    if (size) {
        --size;
        for (size_t n = 0; n < size; n++) {
            int key = rand() % (int) (sizeof charset - 1);
            str[n] = charset[key];
        }
        str[size] = '\0';
    }
    return str;
}
